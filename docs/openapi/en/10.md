[original link](https://swagger.io/docs/specification/data-models/)

## Data Models (Schemas)

OpenAPI 3.0 data types are based on an extended subset [JSON Schema Specification Wright Draft 00](https://tools.ietf.org/html/draft-wright-json-schema-00#section-4.2) (aka Draft 5). 
The data types are described using a [Schema object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#schemaObject). 
To learn how to model various data types, see the following topics:

- [Data Types](https://swagger.io/docs/specification/data-models/data-types/)
- [Enums](https://swagger.io/docs/specification/enums/)
- [Dictionaries, Hashmaps, Associative Arrays](https://swagger.io/docs/specification/data-models/dictionaries/)
- [oneOf, anyOf, allOf, not](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/)
- [Inheritance and Polymorphism](https://swagger.io/docs/specification/data-models/inheritance-and-polymorphism/)
- [Representing XML](https://swagger.io/docs/specification/data-models/representing-xml/)
- [Supported JSON Schema Keywords](https://swagger.io/docs/specification/data-models/keywords/)


## Data Types

The data type of a schema is defined by the `type` keyword, for example, `type: string`. OpenAPI defines the following basic types:

- [`string`](https://swagger.io/docs/specification/data-models/data-types/#string) (this includes dates and [files](https://swagger.io/docs/specification/data-models/data-types/#file))
- [`number`](https://swagger.io/docs/specification/data-models/data-types/#numbers)
- [`integer`](https://swagger.io/docs/specification/data-models/data-types/#numbers)
- [`boolean`](https://swagger.io/docs/specification/data-models/data-types/#boolean)
- [`array`](https://swagger.io/docs/specification/data-models/data-types/#array)
- [`object`](https://swagger.io/docs/specification/data-models/data-types/#object)

These types exist in most programming languages, though they may go  by different names. 
Using these types, you can describe any data  structures.

Note that there is no `null` type; instead, the [`nullable`](https://swagger.io/docs/specification/data-models/data-types/#null) attribute is used as a modifier of the base type.

Additional `type`-specific keywords can be used to refine the data type, for example, limit the string length or specify an [`enum`](https://swagger.io/docs/specification/data-models/enums/) of possible values.

### Mixed Types

`type` takes a single value. 
`type` as a list is not valid in OpenAPI (even though it is valid in JSON Schema):

```yaml
# Incorrect
type:
  - string
  - integer
```

Mixed types can be described using [`oneOf`](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/) and [`anyOf`](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/), which specify a list of alternate types:

```yaml
# Correct
oneOf:
  - type: string
  - type: integer
```

See also [Any Type](https://swagger.io/docs/specification/data-models/data-types/#any).

### Numbers

OpenAPI has two numeric types, `number` and `integer`, where `number` includes both integer and floating-point numbers. 
An optional `format` keyword serves as a hint for the tools to use a specific numeric type:

| `type`  | `format` | Description                                          |
| ------- | -------- | ---------------------------------------------------- |
| number  | –        | Any numbers.                                         |
| number  | float    | Floating-point numbers.                              |
| number  | double   | Floating-point numbers with double precision.        |
| integer | –        | Integer numbers.                                     |
| integer | int32    | Signed 32-bit integers (commonly used integer type). |
| integer | int64    | Signed 64-bit integers (`long` type).                |

Note that strings containing numbers, such as "17", are considered strings and not numbers.

#### Minimum and Maximum

Use the `minimum` and `maximum` keywords to specify the range of possible values:

```yaml
type: integer
minimum: 1
maximum: 20
```

By default, the `minimum` and `maximum` values are included in the range, that is:

```
minimum ≤ value ≤ maximum
```

To exclude the boundary values, specify `exclusiveMinimum: true` and `exclusiveMaximum: true`. 
For example, you can define a floating-point number range as 0–50 and exclude the 0 value:

```yaml
type: number
minimum: 0
exclusiveMinimum: true
maximum: 50
```

The word “exclusive” in `exclusiveMinimum` and `exclusiveMaximum` means the corresponding boundary is *excluded*:

| Keyword                                   | Description       |
| ----------------------------------------- | ----------------- |
| `exclusiveMinimum: false` or not included | value ≥ `minimum` |
| `exclusiveMinimum: true`                  | value > `minimum` |
| `exclusiveMaximum: false` or not included | value ≤ `maximum` |
| `exclusiveMaximum: true`                  | value < `maximum` |

#### Multiples

Use the `multipleOf` keyword to specify that a number must be the multiple of another number:

```yaml
type: integer
multipleOf: 10
```

The example above matches 10, 20, 30, 0, -10, -20, and so on. 
`multipleOf` may be used with floating-point numbers, but in practice this can be  unreliable due to the limited precision or floating point math.

```yaml
type: number
multipleOf: 2.5
```

The value of `multipleOf` must be a positive number, that is, you cannot use `multipleOf: -5`.

### Strings

A string of text is defined as:

```
type: string
```

String length can be restricted using `minLength` and `maxLength`:

```yaml
type: string
minLength: 3
maxLength: 20
```

Note that an empty string "" is a valid string unless `minLength` or [`pattern`](https://swagger.io/docs/specification/data-models/data-types/#pattern) is specified.

#### String Formats

An optional `format` modifier serves as a hint at the contents and format of the string. 
OpenAPI defines the following built-in string formats:

- `date` – full-date notation as defined by [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6), for example, *2017-07-21*
- `date-time` – the date-time notation as defined by [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6), for example, *2017-07-21T17:32:28Z*
- `password` – a hint to UIs to mask the input
- `byte` – base64-encoded characters, for example, *U3dhZ2dlciByb2Nrcw==*
- `binary` – binary data, used to describe files (see [Files](https://swagger.io/docs/specification/data-models/data-types/#file) below)

However, `format` is an open value, so you can use any formats, even not those defined by the OpenAPI Specification, such as:

- `email`
- `uuid`
- `uri`
- `hostname`
- `ipv4`
- `ipv6`
- and others

Tools can use the `format` to validate the input or to map  the value to a specific type in the chosen programming language. 
Tools  that do not support a specific format may default back to the `type` alone, as if the `format` is not specified.

#### pattern

The `pattern` keyword lets you define a regular expression  template for the string value. 
Only the values that match this template  will be accepted. 
The regular expression syntax used is from JavaScript  (more specifically, [ECMA 262](https://www.ecma-international.org/ecma-262/5.1/#sec-15.10.1)). 
Regular expressions are case-sensitive, that is, [a-z] and [A-Z] are  different expressions. 
For example, the following pattern matches a  Social Security Number (SSN) in the 123-45-6789 format:

```yaml
ssn:
  type: string
  pattern: '^\d{3}-\d{2}-\d{4}$'
```

Note that the regular expression is enclosed in the `^…$` tokens, where `^` means the beginning of the string, and `$` means the end of the string. 
Without `^…$`, `pattern` works as a partial match, that is, matches any string that *contains* the specified regular expression. 
For example, `pattern: pet` matches *pet*, *petstore* and *carpet*. 
The `^…$` token forces an exact match.

### Boolean

`type: boolean` represents two values: `true` and `false`. 
Note that truthy and falsy values such as "true", "", 0 or `null` are not considered boolean values.

### Null

OpenAPI 3.0 does not have an explicit `null` type as in JSON Schema, but you can use `nullable: true` to specify that the value may be `null`. 
Note that `null` is different from an empty string "".

```yaml
# Correct
type: integer
nullable: true

# Incorrect
type: null

# Incorrect as well
type:
  - integer
  - null
```

The example above may be mapped to the nullable types `int?` in C# and `java.lang.Integer` in Java. 
In objects, a nullable property is not the same as an optional property, but some tools may choose to map an optional property to the `null` value.

### Arrays

Arrays are defined as:

```yaml
type: array
items:
  type: string
```

Unlike JSON Schema, the `items` keyword is required in arrays. 
The value of `items` is a schema that describes the type and format of array items. 
Arrays can be nested:

```yaml
# [ [1, 2], [3, 4] ]
type: array
items:
  type: array
  items:
    type: integer
```

and contain objects:

```yaml
# [ {"id": 5}, {"id": 8} ]
type: array
items:
  type: object
  properties:
    id:
      type: integer
```

Item schema can be specified inline (as in the previous examples), or referenced via `$ref`:

```yaml
# Array of Pets
type: array
items:
  $ref: '#/components/schemas/Pet'
```

#### Mixed-Type Arrays

Mixed-type arrays can be defined using `oneOf`:

```yaml
# ["foo", 5, -2, "bar"]
type: array
items:
  oneOf:
    - type: string
    - type: integer
```

`oneOf` allows both inline subschemas (as in the example above) and references:

```yaml
# Array of Cats and Dogs
type: array
items:
  oneOf:
    - $ref: '#/components/schemas/Cat'
    - $ref: '#/components/schemas/Dog'
```

An array of arbitrary types can be defined as:

```yaml
type: array
items: {}

# [ "hello", -2, true, [5.7], {"id": 5} ]
```

Here, `{}` is the “any-type” schema (see [below](https://swagger.io/docs/specification/data-models/data-types/#any)). 
Note that the following syntax for `items` is not valid:

```yaml
# Incorrect
items:
  - type: string
  - type: integer

# Incorrect as well
items:
  type: 
    - string
    - integer
```

#### Array Length

You can define the minimum and maximum length of an array like so:

```yaml
type: array
items:
  type: integer
minItems: 1
maxItems: 10
```

Without `minItems`, an empty array is considered valid.

#### uniqueItems

You can use `uniqueItems: true` to specify that all items in the array must be unique:

```yaml
type: array
items:
  type: integer
uniqueItems: true

# [1, 2, 3] – valid
# [1, 1, 3] – not valid
# [ ] – valid
```

### Objects

An object is a collection of property/value pairs. 
The `properties` keyword is used to define the object properties – you need to list the property names and specify a schema for each property.

```yaml
type: object
properties:
  id:
    type: integer
  name:
    type: string
```

**Tip:** In OpenAPI, objects are usually defined in the global `components/schemas` section rather than inline in the request and response definitions.

#### Required Properties

By default, all object properties are optional. 
You can specify the required properties in the `required` list:

```yaml
type: object
properties:
  id:
    type: integer
  username:
    type: string
  name:
    type: string
required:
  - id
  - username
```

Note that `required` is an object-level attribute, not a property attribute:

```yaml
type: object
properties:
  id:
    type: integer
    required: true  # Wrong!

required:           # Correct
  - id
```

An empty list `required: []` is not valid. 
If all properties are optional, do not specify the `required` keyword.

#### Read-Only and Write-Only Properties

You can use the `readOnly` and `writeOnly`  keywords to mark specific properties as read-only or write-only. 
This is useful, for example, when GET returns more properties than used in POST – you can use the same schema in both GET and POST and mark the extra  properties as `readOnly`. 
`readOnly` properties are included in responses but not in requests, and `writeOnly` properties may be sent in requests but not in responses.

```yaml
type: object
properties:
  id:
    # Returned by GET, not used in POST/PUT/PATCH
    type: integer
    readOnly: true
  username:
    type: string
  password:
    # Used in POST/PUT/PATCH, not returned by GET
    type: string
    writeOnly: true
```

If a `readOnly` or `writeOnly` property is included in the `required` list, `required` affects just the relevant scope – responses only or requests only. 
That is, read-only required properties apply to responses only, and  write-only required properties – to requests only.

#### Nested Objects

An object can include nested objects:

```yaml
components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string
        contact_info:
          # The value of this property is an object
          type: object
          properties:
            email:
              type: string
              format: email
            phone:
              type: string
```

You may want to split nested objects into multiple schemas and use [`$ref`](https://swagger.io/docs/specification/using-ref/) to reference the nested schemas:

```yaml
components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string
        contact_info:
          $ref: '#/components/schemas/ContactInfo'

    ContactInfo:
      type: object
      properties:
        email:
          type: string
          format: email
        phone:
          type: string
```

#### Free-Form Object

A free-form object (arbitrary property/value pairs) is defined as:

```yaml
type: object
```

This is equivalent to

```yaml
type: object
additionalProperties: true
```

and

```yaml
type: object
additionalProperties: {}
```

#### Number of Properties

The `minProperties` and `maxProperties` keywords let you restrict the number of properties allowed in an object. 
This can be useful when using `additionalProperties` or free-form objects.

```yaml
type: object
minProperties: 2
maxProperties: 10
```

In this example, `{"id": 5, "username": "trillian"}` matches the schema, but `{"id": 5}` does not.

### Files

Unlike OpenAPI 2.0, Open API 3.0 does not have the `file` type. Files are defined as strings:

```yaml
type: string
format: binary  # binary file contents
```

or

```yaml
type: string
format: byte    # base64-encoded file contents
```

depending on the desired file transfer method. 
For more information, see [File Upload](https://swagger.io/docs/specification/describing-request-body/file-upload/), [Multipart Requests](https://swagger.io/docs/specification/describing-request-body/multipart-requests/) and [Response That Returns a File](https://swagger.io/docs/specification/describing-responses/#response-that-returns-a-file).

### Any Type

A schema without a type matches any data type – numbers, strings, objects, and so on. 
`{}` is shorthand syntax for an arbitrary-type schema:

```yaml
components:
  schemas:
    AnyValue: {}
```

If you want to provide a description:

```yaml
components:
  schemas:
    AnyValue:
      description: Can be any value - string, number, boolean, array or object.
```

The above is equivalent to:

```yaml
components:
  schemas:
    AnyValue:
      anyOf:
        - type: string
        - type: number
        - type: integer
        - type: boolean
        - type: array
          items: {}
        - type: object
```

If the `null` value needs to be allowed, add `nullable: true`:

```yaml
components:
  schemas:
    AnyValue:
      nullable: true
      description: Can be any value, including null.
```

 

*Did not find what you were looking for?*



## Enums

You can use the `enum` keyword to specify possible values of a request parameter or a model property. 
For example, the sort parameter in `GET /items?sort=[asc|desc]` can be described as:

```yaml
paths:
  /items:
    get:
      parameters:
        - in: query
          name: sort
          description: Sort order
          schema:
            type: string
            enum: [asc, desc]
```

In YAML, you can also specify one enum value per line:

```yaml
          enum:
            - asc
            - desc
```

All values in an enum must adhere to the specified `type`. 
If you need to specify descriptions for enum items, you can do this in the `description` of the parameter or property:

```yaml
      parameters:
        - in: query
          name: sort
          schema:
            type: string
            enum: [asc, desc]
          description: >
            Sort order:
             * `asc` - Ascending, from A to Z
             * `desc` - Descending, from Z to A
```

### Nullable enums

A nullable enum can be defined as follows:

```yaml
type: string
nullable: true  # <---
enum:
  - asc
  - desc  
  - null        # <--- without quotes, i.e. null not "null"
```

Note that `null` must be explicitly included in the list of `enum` values. Using `nullable: true` alone [is not enough](https://github.com/OAI/OpenAPI-Specification/blob/master/proposals/003_Clarify-Nullable.md#if-a-schema-specifies-nullable-true-and-enum-1-2-3-does-that-schema-allow-null-values-see-1900) here.



### Reusable enums

In OpenAPI 3.0, both operation parameters and data models use a `schema`, making it easy to reuse the data types. 
You can define reusable enums in the global `components` section and reference them via `$ref` elsewhere.

```yaml
paths:
  /products:
    get:
      parameters:
      - in: query
        name: color
        required: true
        schema:
          $ref: '#/components/schemas/Color'
      responses:
        '200':
          description: OK
components:
  schemas:
    Color:
      type: string
      enum:
        - black
        - white
        - red
        - green
        - blue
```

### Dictionaries, HashMaps and Associative Arrays

A dictionary (also known as a map, hashmap or associative array) is a set of key/value pairs.  
OpenAPI lets you define dictionaries where the **keys are strings**. 
To define a dictionary, use `type: object` and use the `additionalProperties` keyword to specify the type of values in key/value pairs. 
For example, a string-to-string dictionary like this:

```json
{
  "en": "English",
  "fr": "French"
}
```

is defined using the following schema:

```yaml
type: object
additionalProperties:
  type: string
```

### Value Type

The `additionalProperties` keyword specifies the type of  values in the dictionary. 
Values can be primitives (strings, numbers or  boolean values), arrays or objects. 
For example, a string-to-object  dictionary can be defined as follows:

```yaml
type: object
additionalProperties:
  type: object
  properties:
    code:
      type: integer
    text:
      type: string
```

Instead of using an inline schema, `additionalProperties` can `$ref` another schema: 

```yaml
components:
  schemas:
    Messages:        # <---- dictionary
      type: object
      additionalProperties:
        $ref: '#/components/schemas/Message'

    Message:
      type: object
      properties:
        code:
          type: integer
        text:
          type: string
```

### Free-Form Objects

If the dictionary values can be of any type (aka free-form object), use `additionalProperties: true`:

```yaml
type: object
additionalProperties: true
```

This is equivalent to:

```yaml
type: object
additionalProperties: {}
```

### Fixed Keys

If a dictionary has some fixed keys, you can define them explicitly as object properties and mark them as required:

```yaml
type: object
properties:
  default:
    type: string
required:
  - default
additionalProperties:
  type: string
```

### Examples of Dictionary Contents

You can use the `example` keyword to specify sample dictionary contents:

```yaml
type: object
additionalProperties:
  type: string
example:
  en: Hello!
  fr: Bonjour!
```


## oneOf, anyOf, allOf, not

OpenAPI 3.0 provides several keywords which you can use to combine  schemas. You can use these keywords to create a complex schema, or  validate a value against multiple criteria.

- [`oneOf`](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/#oneof) – validates the value against *exactly one* of the subschemas
- [`allOf`](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/#allof) – validates the value against *all* the subschemas
- [`anyOf`](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/#anyof) – validates the value against *any* (one or more) of the subschemas

Besides these, there is a [`not`](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/#not) keyword which you can use to make sure the value is *not* valid against the specified schema.

### oneOf

Use the `oneOf` keyword to ensure the given data is valid against one of the specified schemas.

```yaml
paths:
  /pets:
    patch:
      requestBody:
        content:
          application/json:
            schema:
              oneOf:
                - $ref: '#/components/schemas/Cat'
                - $ref: '#/components/schemas/Dog'
      responses:
        '200':
          description: Updated

components:
  schemas:
    Dog:
      type: object
      properties:
        bark:
          type: boolean
        breed:
          type: string
          enum: [Dingo, Husky, Retriever, Shepherd]
    Cat:
      type: object
      properties:
        hunts:
          type: boolean
        age:
          type: integer
```

The example above shows how to validate the request body in the “update” operation (PATCH). 
You can use it to validate the request body contains all the necessary information about the object to be updated, depending on the object type. 
Note the inline or referenced schema must be a *schema object*, not a standard JSON Schema. 
Now, to validation. 
The following JSON object is **valid** against one of the schemas, so the response body is *correct*:

```json
{
  "bark": true,
  "breed": "Dingo" 
}
```

The following JSON object is **not valid** against both schemas, so the response body is *incorrect*:

```json
{
  "bark": true,
  "hunts": true
}
```

The following JSON object is **valid** against **both** schemas, so the response body is *incorrect* – it should be valid against only one of the schemas, since we are using the `oneOf` keyword.

```json
{
  "bark": true,
  "hunts": true,
  "breed": "Husky",
  "age": 3 		
}
```

### allOf

OpenAPI lets you combine and extend model definitions using the `allOf` keyword. 
`allOf` takes an array of object definitions that are used for independent  validation but together compose a single object. 
Still, it does not  imply a hierarchy between the models. 
For that purpose, you should  include the [`discriminator`](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#discriminatorObject). 
To be valid against `allOf`, the data provided by the client must be valid against all of the given subschemas. 
In the following example, `allOf` acts as a tool for combining schemas used in specific cases with the general one. For more clearness, `oneOf` is also used with a `discriminator`.

```yaml
paths:
  /pets:
    patch:
      requestBody:
        content:
          application/json:
            schema:
              oneOf:
                - $ref: '#/components/schemas/Cat'
                - $ref: '#/components/schemas/Dog'
              discriminator:
                propertyName: pet_type
      responses:
        '200':
          description: Updated

components:
  schemas:
    Pet:
      type: object
      required:
        - pet_type
      properties:
        pet_type:
          type: string
      discriminator:
        propertyName: pet_type

    Dog:     # "Dog" is a value for the pet_type property (the discriminator value)
      allOf: # Combines the main `Pet` schema with `Dog`-specific properties 
        - $ref: '#/components/schemas/Pet'
        - type: object
          # all other properties specific to a `Dog`
          properties:
            bark:
              type: boolean
            breed:
              type: string
              enum: [Dingo, Husky, Retriever, Shepherd]

    Cat:     # "Cat" is a value for the pet_type property (the discriminator value)
      allOf: # Combines the main `Pet` schema with `Cat`-specific properties 
        - $ref: '#/components/schemas/Pet'
        - type: object
          # all other properties specific to a `Cat`
          properties:
            hunts:
              type: boolean
            age:
              type: integer
```

As you can see, this example validates the request body content to make  sure it includes all the information needed to update a pet item with  the PUT operation. 
It requires user to specify which type of the item  should be updated, and validates against the specified schema according  to their choice. 
Note the inline or referenced schema must be a *schema object*, not a standard JSON schema. 
For that example, all of the following request bodies are **valid**:

```json
{
  "pet_type": "Cat",
  "age": 3
}
{
  "pet_type": "Dog",
  "bark": true
}
{
  "pet_type": "Dog",
  "bark": false,
  "breed": "Dingo"
}
```

The following request bodies are **not valid**:

```yaml
{
  "age": 3        # Does not include the pet_type property
}
```

```yaml
{
  "pet_type": "Cat", 
  "bark": true    # The `Cat` schema does not have the `bark` property 
}
```

### anyOf

Use the `anyOf` keyword to validate the data against any  amount of the given subschemas. 
That is, the data may be valid against  one or more subschemas at the same time.

```yaml
paths:
  /pets:
    patch:
      requestBody:
        content:
          application/json:
            schema:
              anyOf:
                - $ref: '#/components/schemas/PetByAge'
                - $ref: '#/components/schemas/PetByType'
      responses:
        '200':
          description: Updated

components:
  schemas:
    PetByAge:
      type: object
      properties: 
        age: 
          type: integer
        nickname: 
          type: string
      required:
        - age
          
    PetByType:
      type: object
      properties:
        pet_type:
          type: string
          enum: [Cat, Dog]
        hunts:
          type: boolean
      required: 
        - pet_type
```


Note the inline or referenced schema must be a *schema object*, not a standard JSON schema. 
With this example, the following JSON request bodies are **valid**:

```
{  "age": 1}
{  "pet_type": "Cat",  "hunts": true}
{  "nickname": "Fido",  "pet_type": "Dog",  "age": 4}
```

The following example is **not valid**, because it does not contain any of the required properties for both of the schemas:

```
{  "nickname": "Mr. Paws",  "hunts": false}
```

### Difference Between anyOf and oneOf

`oneOf` matches exactly one subschema, and `anyOf` can match one or more subschemas. 
To better understand the difference, use the example [above](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/#difference) but replace `anyOf` with `oneOf`. 
When using `oneOf`, the following request body is **not valid** because it matches both schemas and not just one:

```json
{
  "nickname": "Fido",
  "pet_type": "Dog",
  "age": 4
}
```

### not

The `not` keyword does not exactly combine schemas, but as  all of the keywords mentioned above it helps you to modify your schemas  and make them more specific.

```yaml
paths:
  /pets:
    patch:
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PetByType'
      responses:
        '200':
          description: Updated

components:
  schemas:          
    PetByType:
      type: object
      properties:
        pet_type:
          not:
            type: integer
      required:
        - pet_type
```

In this example, user should specify the `pet_type` value of  any type except integer (that is, it should be an array, boolean,  number, object, or string). The following request body is **valid**:

```
{  "pet_type": "Cat"}
```

And the following is **not valid**:

```
{  "pet_type": 11}
```


## Inheritance and Polymorphism

### Model Composition

In your API, you may have model schemas that share common properties.  Instead of describing these properties for each schema repeatedly, you  can describe the schemas as a composition of the common property set and schema-specific properties. In OpenAPI version 3, you do this with the `allOf` keyword:

```yaml
components:
  schemas:
    BasicErrorModel:
      type: object
      required:
        - message
        - code
      properties:
        message:
          type: string
        code:
          type: integer
          minimum: 100
          maximum: 600
    ExtendedErrorModel:
      allOf:     # Combines the BasicErrorModel and the inline model
        - $ref: '#/components/schemas/BasicErrorModel'
        - type: object
          required:
            - rootCause
          properties:
            rootCause:
              type: string
```

In the example above, the `ExtendedErrorModel` schema includes its own properties and properties inherited from `BasicErrorModel`. **Note:** When validating the data, servers and clients will validate the  combined model against each model it consists of. It is recommended to  avoid using conflicting properties (like properties that have the same  names, but different data types).

### Polymorphism

In your API, you can have request and responses that can be described by several alternative schemas. In OpenAPI 3.0, to describe such a model,  you can use the `oneOf` or `anyOf` keywords:

```yaml
components:
  responses:
    sampleObjectResponse:
      content:
        application/json:
          schema:
            oneOf:
              - $ref: '#/components/schemas/simpleObject'
              - $ref: '#/components/schemas/complexObject'
  …
components:
  schemas:
    simpleObject:
      …
    complexObject:
      …
```

In this example, the response payload can contain either `simpleObject`, or `complexObject`.

### Discriminator

To help API consumers detect the object type, you can add the `discriminator/propertyName` keyword to model definitions. This keyword points to the property that specifies the data type name:

```yaml
components:
  responses:
    sampleObjectResponse:
      content:
        application/json:
          schema:
            oneOf:
              - $ref: '#/components/schemas/simpleObject'
              - $ref: '#/components/schemas/complexObject'
            discriminator:
              propertyName: objectType
  …
  schemas:
    simpleObject:
      type: object
      required:
        - objectType
      properties:
        objectType:
          type: string
      …
    complexObject:
      type: object
      required:
        - objectType
      properties:
        objectType:
          type: string
      …
```

In our example, the discriminator points to the `objectType` property that contains the data type name. 
The discriminator is used with `anyOf` or `oneOf` keywords only. 
It is important that all the models mentioned below `anyOf` or `oneOf` contain the property that the discriminator specifies. 
This means, for example, that in our code above, both `simpleObject` and `complexObject` must have the `objectType` property. 
This property is required in these schemas:

```yaml
schemas:
    simpleObject:
      type: object
      required:
        - objectType
      properties:
        objectType:
          type: string
      …
    complexObject:
      type: object
      required:
        - objectType
      properties:
        objectType:
          type: string
      …
```

The `discriminator` keyword can be used by various API  consumers. 
One possible example are code generation tools: they can use  discriminator to generate program statements that typecast request data  to appropriate object type based on the discriminator property value.

### Mapping Type Names

It is implied, that the property to which discriminator refers, contains the name of the target schema. 
In the example above, the `objectType` property should contain either `*simpleObject*`, or `*complexObject*` string. 
If the property values do not match the schema names, you can map the values to the names. 
To do this, use the `discriminator/mapping` keyword:

```yaml
components:
  responses:
    sampleObjectResponse:
      content:
        application/json:
          schema:
            oneOf:
              - $ref: '#/components/schemas/Object1'
              - $ref: '#/components/schemas/Object2'
              - $ref: 'sysObject.json#/sysObject'
            discriminator:
              propertyName: objectType
              mapping:
                obj1: '#/components/schemas/Object1'
          obj2: '#/components/schemas/Object2'
            system: 'sysObject.json#/sysObject'
  …
  schemas:
    Object1:
      type: object
      required:
        - objectType
      properties:
        objectType:
          type: string
      …
    Object2:
      type: object
      required:
        - objectType
      properties:
        objectType:
          type: string
      …
```

In this example, the `*obj1*` value is mapped to the `Object1` model that is defined in the same spec, `*obj2*` – to `Object2`, and the value `*system*` matches the `sysObject` model that is located in an external file. 
All these objects must have the `objectType` property with the value `*"obj1"*`, `*"obj2"*` or `*"system"*`, respectively.


## Representing XML

In your API specification, you can describe data in both XML and JSON formats as they are easily interchangeable. For example, the following  declaration —

```yaml
components:
  schemas:
    book:
      type: object
      properties:
        id:
          type: integer
        title:
          type: string
        author: 
          type: string
```

— is represented in the following way in JSON and XML:

| JSON | XML |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `{   "id": 0,   "title": "string",   "author": "string" } `  | `<book>   <id>0</id>   <title>string</title>   <author>string</author> </book> ` |

As you can see, in XML representation, the object name serves as a  parent element and properties are translated to child elements. The  OpenAPI 3 format offers a special `xml` object to help you  fine-tune representation of XML data. You can use this object to  transform some properties to attributes rather than elements, to change  element names, to add namespaces and to control transformations of array items.

### Change Element Names

By default, XML elements get the same names that fields in the API declaration have. To change the default behavior, add the `xml/name` field to your spec:

**Element name**

| Specification 			`components:  schemas:    book:      type: object      properties:        id:          type: integer        title:          type: string        author:           type: string      xml:        name: 'xml-book'` | XML 			`<xml-book>	<id>0</id>	<title>string</title>	<author>string</author></xml-book>` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

**Attribute name**

| Specification 			`components:  schemas:    book:      type: object      properties:        id:          type: integer        title:          type: string          xml:            name: 'xml-title'        author:           type: string` | XML 			`<book>	<id>0</id>	<xml-title>string</xml-title>	<author>string</author></book>` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

For arrays, the `xml/name` property works only if another property – `xml/wrapped` – is set to `true`. See below.

### Convert Property to an Attribute

As we said above, by default, properties are transformed to child  elements of the parent “object” element. To make some property an  attribute in the resulting XML data, use the `xml/attribute`:

| Specification 			`book:      type: object      properties:        id:          type: integer          xml:            attribute: true        title:          type: string        author:           type: string` | XML 			`<book id="0">	<title>string</title>	<author>string</author></book>` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

This works only for properties. Using `xml/attribute` for objects is meaningless.

### Prefixes and Namespaces

To avoid element name conflicts, you can specify namespace and prefix for elements. The namespace value must be an absolute URI:

```
xml:  prefix: 'smp'  namespace: 'http://example.com/schema'
```

Namespace prefixes will be ignored for JSON:

```
{"author": "Mark Twain"}
```

The example below shows how you can add namespaces and prefixes:

| Specification 			`book:  type: object  properties:    id:      type: integer    title:      type: string    author:       type: string  xml:    prefix: 'smp'    namespace: 'http://example.com/schema'` | XML 			`<smp:book xmlns:smp="http://example.com/schema">	<id>0</id>	<title>string</title>	<author>string</author></smp:book>` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

If needed, you can specify only `prefix` (This works in case the namespace is defined in some parent element). You can also specify prefixes for attributes.

### Wrapping Arrays

Arrays are translated as a sequence of elements of the same name:

| Specification 			`books:  type: array  items:     type: string    example:    - 'one'    - 'two'    - 'three'` | XML 			`<books>one</books><books>two</books><books>three</books>` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

If needed, you can add a wrapping element by using the `xml/wrapped` property:

| Specification 			`books:  type: array  items:     type: string   xml:    wrapped : true  example:    - 'one'    - 'two'    - 'three'` | XML 			`<books>  <books>one</books>  <books>two</books>  <books>three</books></books>` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

As you can see, by default, the wrapping element has the same name as item elements. Use `xml/name` to give different names to the wrapping element and array items (this will help you resolve possible naming issues):

| Specification 			`books:  type: array  items:     type: string     xml:      name: 'item'  xml:    wrapped : true    name: books-array  example:    - 'one'    - 'two'    - 'three'` | XML 			`<books-array>  <item>one</item>  <item>two</item>  <item>three</item></books-array>` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

Note that the `xml.name` property of the wrapping element (`books` in our example) has effect only if `wrapped` is *true*. If `wrapped` is *false*, `xml.name` of the wrapping element is ignored.

### Reference

[XML Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#xmlObject)


## Supported JSON Schema Keywords

OpenAPI 3.0 uses an extended subset of [JSON Schema Specification](http://json-schema.org) Wright Draft 00 (aka Draft 5) to describe the data formats. 
“Extended  subset” means that some keywords are supported and some are not, some  keywords have slightly different usage than in JSON Schema, and  additional keywords are introduced.

### Supported Keywords

These keywords have the **same meaning** as in JSON Schema:

- `title`
- [`pattern`](https://swagger.io/docs/specification/data-models/data-types/#pattern)
- [`required`](https://swagger.io/docs/specification/data-models/data-types/#required)
- [`enum`](https://swagger.io/docs/specification/data-models/enums/)
- [`minimum`](https://swagger.io/docs/specification/data-models/data-types/#range)
- [`maximum`](https://swagger.io/docs/specification/data-models/data-types/#range)
- [`exclusiveMinimum`](https://swagger.io/docs/specification/data-models/data-types/#range)
- [`exclusiveMaximum`](https://swagger.io/docs/specification/data-models/data-types/#range)
- [`multipleOf`](https://swagger.io/docs/specification/data-models/data-types/#multipleOf)
- [`minLength`](https://swagger.io/docs/specification/data-models/data-types/#string)
- [`maxLength`](https://swagger.io/docs/specification/data-models/data-types/#string)
- [`minItems`](https://swagger.io/docs/specification/data-models/data-types/#array-length)
- [`maxItems`](https://swagger.io/docs/specification/data-models/data-types/#array-length)
- [`uniqueItems`](https://swagger.io/docs/specification/data-models/data-types/#uniqueItems)
- [`minProperties`](https://swagger.io/docs/specification/data-models/data-types/#property-count)
- [`maxProperties`](https://swagger.io/docs/specification/data-models/data-types/#property-count)

These keywords are **supported with minor differences**:

- [`type`](https://swagger.io/docs/specification/data-models/data-types/#type) – the value must be a single type and not an array of types. `null` is not supported as a type, use the [`nullable: true`](https://swagger.io/docs/specification/data-models/data-types/#null) keyword instead.
- `format` – OpenAPI has its own predefined formats and also allows custom formats.
- `description` – supports [CommonMark](http://commonmark.org/help/) syntax for rich text representation.
- [`items`](https://swagger.io/docs/specification/data-models/data-types/#array) – must be present if `type` is `array`. The item schema must be an OpenAPI schema and not a standard JSON Schema.
- [`properties`](https://swagger.io/docs/specification/data-models/data-types/#object) – individual property definitions must follow OpenAPI schema rules and not standard JSON Schema.
- [`additionalProperties`](https://swagger.io/docs/specification/data-models/data-types/#additionalProperties) – the value can be a boolean (`true` or `false`) or an OpenAPI schema.
- [`default`](https://swagger.io/docs/specification/data-models/data-types/#default) – the default value must conform to the specified schema.
- [`allOf`](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/) – the subschemas must be OpenAPI schemas and not standard JSON Schemas.
- [`oneOf`](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/) – the subschemas must be OpenAPI schemas and not standard JSON Schemas.
- [`anyOf`](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/) – the subschemas must be OpenAPI schemas and not standard JSON Schemas.
- [`not`](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/) – the subschema must be an OpenAPI schema and not a standard JSON Schema.

### Unsupported Keywords

- `$schema`
- `additionalItems`
- `const`
- `contains`
- `dependencies`
- `id`,
- `$id`
- `patternProperties`
- `propertyNames`

### Additional Keywords

OpenAPI schemas can also use the following keywords that are not part of JSON Schema:

- `deprecated`
- [`discriminator`](https://swagger.io/docs/specification/data-models/inheritance-and-polymorphism/)
- [`example`](https://swagger.io/docs/specification/adding-examples/)
- `externalDocs`
- [`nullable`](https://swagger.io/docs/specification/data-models/data-types/#null)
- [`readOnly`](https://swagger.io/docs/specification/data-models/data-types/#readonly-writeonly)
- [`writeOnly`](https://swagger.io/docs/specification/data-models/data-types/#readonly-writeonly)
- [`xml`](https://swagger.io/docs/specification/data-models/representing-xml/)

### References

[OpenAPI 3.0 – Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#schema-object)

[JSON Schema Validation](https://tools.ietf.org/html/draft-wright-json-schema-validation-00) – JSON Schema keyword reference

[JSON Schema Draft Wright 00](https://tools.ietf.org/html/draft-wright-json-schema-00) – Core JSON Schema Specification
